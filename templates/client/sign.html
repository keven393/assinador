<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assinatura - Assinador Digital</title>
    <link href="{{ url_for('static', filename='css/bootstrap.min.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/font-awesome.min.css') }}" rel="stylesheet">
    
</head>
<body>
    <div class="container">
        <div class="client-container">
            <!-- Header -->
            <div class="client-header">
                <div class="logo-icon">
                    <i class="fas fa-pen-fancy"></i>
                </div>
                <h2 class="mb-2">Assinatura Digital</h2>
                <p class="mb-0">Desenhe sua assinatura no campo abaixo</p>
            </div>

            <!-- Body -->
            <div class="client-body">
                <!-- Informações do Documento -->
                <div class="document-info">
                    <h5 class="mb-3">
                        <i class="fas fa-file-pdf me-2 text-danger"></i>
                        Documento para Assinatura
                    </h5>
                    <div class="row">
                        <div class="col-md-8">
                            <strong>{{ signature.original_filename }}</strong>
                            <br>
                            <small class="text-muted">
                                Cliente: {{ signature.client_name }} | 
                                CPF: {{ signature.client_cpf|cpf }}
                            </small>
                        </div>
                        <div class="col-md-4 text-end">
                            <span class="badge bg-warning">
                                <i class="fas fa-clock me-1"></i>Aguardando Assinatura
                            </span>
                        </div>
                    </div>
                </div>

                <!-- Instruções -->
                <div class="signature-instructions">
                    <h6 class="mb-2">
                        <i class="fas fa-info-circle me-2"></i>
                        Instruções para Assinatura
                    </h6>
                    <ul class="mb-0">
                        <li>Use o dedo ou caneta para desenhar sua assinatura no campo abaixo</li>
                        <li>Certifique-se de que a assinatura esteja clara e legível</li>
                        <li>Você pode apagar e refazer quantas vezes quiser</li>
                        <li>Clique em "Finalizar Assinatura" quando estiver satisfeito</li>
                    </ul>
                </div>

                <!-- Área de Assinatura -->
                <div class="signature-area">
                    <h5 class="mb-3 text-center">
                        <i class="fas fa-signature me-2 text-primary"></i>
                        Sua Assinatura
                    </h5>
                    
                    <div class="canvas-container position-relative">
                        <canvas id="signatureCanvas" width="600" height="200"></canvas>
                        <button class="expand-btn" id="expandBtn" title="Expandir área de assinatura">
                            <i class="fas fa-expand-arrows-alt"></i>
                        </button>
                    </div>
                    
                    <div class="canvas-controls">
                        <div class="btn-group-signature">
                            <button type="button" class="btn btn-outline-secondary" id="clearBtn">
                                <i class="fas fa-eraser me-2"></i>Limpar
                            </button>
                            <button type="button" class="btn btn-outline-primary" id="undoBtn">
                                <i class="fas fa-undo me-2"></i>Desfazer
                            </button>
                            <button type="button" class="btn btn-success" id="signBtn" disabled>
                                <i class="fas fa-check me-2"></i>Finalizar Assinatura
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Indicador de Progresso -->
                <div class="progress-indicator">
                    <div class="d-flex align-items-center">
                        <i class="fas fa-clipboard-check me-2 text-warning"></i>
                        <div class="flex-grow-1">
                            <strong>Etapa 3 de 3:</strong> Assinatura do Documento
                        </div>
                        <span class="badge bg-success">75%</span>
                    </div>
                </div>

                <!-- Botões de Navegação -->
                <div class="d-grid gap-2">
                    <a href="{{ url_for('client_confirm_document', signature_id=signature.id) }}" class="btn btn-outline-secondary btn-client">
                        <i class="fas fa-arrow-left me-2"></i>
                        Voltar
                    </a>
                </div>
            </div>
        </div>
        
        <!-- Mobile Signature Dialog - DENTRO DO CONTAINER -->
        <div class="signature-dialog" id="signatureDialog">
            <div class="dialog-content">
                <div class="dialog-header">
                    <h5 class="dialog-title">
                        <i class="fas fa-signature"></i>
                        Desenhe sua Assinatura
                    </h5>
                    <button class="dialog-close" id="dialogCloseBtn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                
                <div class="dialog-canvas-container">
                    <canvas id="dialogCanvas" class="dialog-canvas"></canvas>
                </div>
                
                <div class="dialog-controls">
                    <div class="color-picker-group">
                        <span class="me-2 fw-bold">Cor:</span>
                        <div class="color-picker active" data-color="#000" style="background: #000;"></div>
                    </div>
                    
                    <div class="dialog-buttons">
                        <button class="dialog-btn dialog-btn-clear" id="dialogClearBtn">
                            <i class="fas fa-eraser"></i>Limpar
                        </button>
                        <button class="dialog-btn dialog-btn-undo" id="dialogUndoBtn">
                            <i class="fas fa-undo"></i>Desfazer
                        </button>
                        <button class="dialog-btn dialog-btn-done" id="dialogDoneBtn">
                            <i class="fas fa-check"></i>Concluir
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="{{ url_for('static', filename='js/bootstrap.bundle.min.js') }}"></script>
    
    <!-- HUDs: validação, confirmação, sucesso e erro -->
    <div class="modal fade" id="signValidationModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-triangle-exclamation text-warning me-2"></i> Atenção</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p id="signValidationText" class="mb-0"></p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ok</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="signConfirmModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-question-circle text-primary me-2"></i> Confirmar</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    Tem certeza que deseja finalizar a assinatura? Esta ação não pode ser desfeita.
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancelar</button>
                    <button type="button" class="btn btn-primary" id="signConfirmBtn"><i class="fas fa-check me-1"></i>Confirmar</button>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="signSuccessModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-check-circle text-success me-2"></i> Sucesso</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p id="signSuccessText" class="mb-0"></p>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="signErrorModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><i class="fas fa-times-circle text-danger me-2"></i> Erro</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p id="signErrorText" class="mb-0"></p>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Configuração do canvas
        const DIALOG_ASPECT_LANDSCAPE = 3 / 1; // ex.: 3:1 no modo paisagem
        const DIALOG_ASPECT_PORTRAIT  = 4 / 3; // ex.: 4:3 no modo retrato
        const DPR = window.devicePixelRatio || 1;
        const canvas = document.getElementById('signatureCanvas');
        const ctx = canvas.getContext('2d');
        const clearBtn = document.getElementById('clearBtn');
        const undoBtn = document.getElementById('undoBtn');
        const signBtn = document.getElementById('signBtn');
        console.log('signBtn encontrado:', signBtn);
        if (!signBtn) {
            console.error('signBtn não encontrado!');
        }
        
         // Dialog elements
         const expandBtn = document.getElementById('expandBtn');
         const signatureDialog = document.getElementById('signatureDialog');
         const dialogCanvas = document.getElementById('dialogCanvas');
         const dialogCtx = dialogCanvas.getContext('2d');
         const dialogCloseBtn = document.getElementById('dialogCloseBtn');
         const dialogClearBtn = document.getElementById('dialogClearBtn');
         const dialogUndoBtn = document.getElementById('dialogUndoBtn');
         const dialogDoneBtn = document.getElementById('dialogDoneBtn');
         
         let isDrawing = false;
         let hasSignature = false;
         let signatureHistory = [];
         let currentPath = [];
         
         // Dialog variables
         let dialogPaths = [];
         let dialogCurrentPath = [];
         let isDialogDrawing = false;
         let currentColor = '#000';
         
         // Tamanhos lógicos (CSS px) atuais de cada canvas
         let mainLogicalSize = { w: 600, h: 200 };
         let dialogLogicalSize = { w: 600, h: 200 };
        
        // Enhanced mobile/tablet detection for all browsers including Samsung Internet
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|SamsungBrowser|Samsung/i.test(navigator.userAgent);
        const isTablet = /iPad|Android(?!.*Mobile)|Tablet/i.test(navigator.userAgent) || 
                        (navigator.maxTouchPoints && navigator.maxTouchPoints > 1 && window.innerWidth >= 768);
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isSamsungInternet = /SamsungBrowser|Samsung/i.test(navigator.userAgent);
        const devicePixelRatio = window.devicePixelRatio || 1; // Para high-DPI
        
        console.log('Device detection:', {
            isMobile,
            isTablet, 
            isTouchDevice,
            isSamsungInternet,
            userAgent: navigator.userAgent,
            maxTouchPoints: navigator.maxTouchPoints,
            devicePixelRatio,
            screenWidth: window.innerWidth
        });
        
        function fitCanvasHiDPI(canvasElement, context, cssWidth, cssHeight) {
            // Tamanho interno (físico)
            canvasElement.width  = Math.round(cssWidth * DPR);
            canvasElement.height = Math.round(cssHeight * DPR);
            // Tamanho visual (CSS)
            canvasElement.style.width  = cssWidth + 'px';
            canvasElement.style.height = cssHeight + 'px';
            // Reset e aplica transformação: desenhar em CSS pixels
            context.setTransform(DPR, 0, 0, DPR, 0, 0);
            }
        // Configurações do canvas (com suporte a high-DPI)
        function setupCanvasContext() {
            ctx.strokeStyle = '#000';
            ctx.lineWidth = isMobile ? 3 : 2; // em CSS px; não multiplique por DPR
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            }
        
        // Dialog canvas setup
        function setupDialogContext() {
            dialogCtx.strokeStyle = currentColor;
            dialogCtx.lineWidth = (isMobile ? 3 : 2); // em CSS px
            dialogCtx.lineCap = 'round';
            dialogCtx.lineJoin = 'round';
            }
        
        // Função precisa para obter coordenadas (corrige offset em mobile/high-DPI)
        function getPointerPos(e, canvasElement) {
            const rect = canvasElement.getBoundingClientRect();
            const touch = e.touches?.[0] || e.changedTouches?.[0] || e;
            const clientX = touch.clientX;
            const clientY = touch.clientY;
            // Retorna coordenadas em CSS pixels (sem aplicar DPR novamente)
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
            }
         
         // Responsive canvas sizing (com high-DPI)
         function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 40;
            const logicalWidth = isMobile ? Math.min(containerWidth, 400) : Math.min(containerWidth, 600);
            const logicalHeight = 200;
            fitCanvasHiDPI(canvas, ctx, logicalWidth, logicalHeight);
            setupCanvasContext();
            
            // Atualiza tamanho lógico
            mainLogicalSize.w = logicalWidth;
            mainLogicalSize.h = logicalHeight;
            
            redrawCanvas();
            }
         
         // Dialog canvas setup (com high-DPI)
         function setupDialogCanvas() {
            const container = document.querySelector('.dialog-canvas-container');
            const styles = getComputedStyle(container);
            const paddingX = parseFloat(styles.paddingLeft) + parseFloat(styles.paddingRight);
            const paddingY = parseFloat(styles.paddingTop) + parseFloat(styles.paddingBottom);
            // Largura disponível (em CSS px)
            const containerWidth = container.clientWidth; // inclui padding
            const innerWidth = Math.max(300, Math.round(containerWidth - paddingX));
            // Define razão de aspecto conforme orientação
            const portrait = window.matchMedia('(orientation: portrait)').matches;
            const aspect = portrait ? DIALOG_ASPECT_PORTRAIT : DIALOG_ASPECT_LANDSCAPE;
            // Altura interna proporcional (em CSS px)
            let innerHeight = Math.round(innerWidth / aspect);
            // Limites de altura para não estourar o dialog
            // Você pode ajustar esses limites conforme seu layout
            const MIN_INNER_HEIGHT = 200;
            const MAX_INNER_HEIGHT = Math.round(window.innerHeight * 0.6);
            innerHeight = Math.max(MIN_INNER_HEIGHT, Math.min(innerHeight, MAX_INNER_HEIGHT));
            // Ajusta a altura do container para acompanhar o canvas (altura interna + paddings)
            container.style.height = (innerHeight + paddingY) + 'px';
            // Configura o canvas em HiDPI
            dialogCanvas.width  = Math.round(innerWidth * DPR);
            dialogCanvas.height = Math.round(innerHeight * DPR);
            dialogCanvas.style.width  = innerWidth + 'px';
            dialogCanvas.style.height = innerHeight + 'px';
            // Desenha em coordenadas de CSS px; DPR aplicado aqui
            dialogCtx.setTransform(DPR, 0, 0, DPR, 0, 0);
            setupDialogContext();
            
            // Atualiza tamanho lógico do dialog
            dialogLogicalSize.w = innerWidth;
            dialogLogicalSize.h = innerHeight;
            
            // Redesenha, se já tiver conteúdo
            if (typeof redrawDialogCanvas === 'function') {
                redrawDialogCanvas();
            }
        }

         
        
        // Reescala paths de um tamanho lógico para outro
        function scalePaths(srcPaths, fromW, fromH, toW, toH) {
            if (!srcPaths || !srcPaths.length) return [];
            const sx = toW / fromW;
            const sy = toH / fromH;
            return srcPaths.map(path => {
                // path pode ser array de pontos {x,y} ou {x,y,color}
                return path.map(p => ({
                    x: p.x * sx,
                    y: p.y * sy,
                    color: p.color || '#000'
                }));
            });
        }
        
        // Função para limpar canvas corretamente
        function clearCanvas(context, canvasElement) {
            context.save();
            context.setTransform(1, 0, 0, 1, 0, 0);
            context.clearRect(0, 0, canvasElement.width, canvasElement.height);
            context.restore();
        }
        
        // Função para coletar informações do dispositivo
        function collectDeviceInfo() {
            return {
                screenResolution: `${screen.width}x${screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                language: navigator.language,
                platform: navigator.platform,
                userAgent: navigator.userAgent,
                cookieEnabled: navigator.cookieEnabled,
                onlineStatus: navigator.onLine
            };
        }
        
        // Mouse events (mantidos para desktop)
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        // Touch events corrigidos (sem preventDefault excessivo)
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length > 1) return; // Ignora multi-touch
            startDrawing(e);
        }, { passive: true }); // Passive para performance
        
        canvas.addEventListener('touchmove', throttledDraw, { passive: true });
        canvas.addEventListener('touchend', stopDrawing, { passive: true });
        
        // Pointer Events como fallback unificado (melhor compatibilidade)
        canvas.addEventListener('pointerdown', (e) => {
            if (e.pointerType === 'touch') {
                canvas.setPointerCapture(e.pointerId);
                startDrawing(e);
            }
        });
        canvas.addEventListener('pointermove', (e) => {
            if (e.pointerType === 'touch' && isDrawing) {
                draw(e);
            }
        });
        canvas.addEventListener('pointerup', (e) => {
            if (e.pointerType === 'touch') {
                stopDrawing(e);
            }
        });
        
        // Auto-open dialog on mobile/tablet touch - Enhanced for all browsers
        if (isMobile || isTablet || isTouchDevice) {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                openSignatureDialog();
            }, { passive: false });
        }
        
        // Eventos unificados com Pointer Events (melhor para cross-device)
        function startDrawing(e) {
            e.preventDefault(); // Só no canvas, não propaga
            isDrawing = true;
            const coords = getPointerPos(e, canvas);
            currentPath = [{x: coords.x, y: coords.y}];
            ctx.beginPath();
            ctx.moveTo(coords.x, coords.y);
        }
        
        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const coords = getPointerPos(e, canvas);
            currentPath.push({x: coords.x, y: coords.y});
            ctx.lineTo(coords.x, coords.y);
            ctx.stroke();
        }
        
        function stopDrawing(e) {
            if (isDrawing) {
                isDrawing = false;
                if (currentPath.length > 0) {
                    signatureHistory.push([...currentPath]);
                    currentPath = [];
                    hasSignature = true;
                    updateSignButton();
                }
            }
        }
        
        // Throttled touchmove para performance (evita lag em mobile)
        let lastTouchMove = 0;
        function throttledDraw(e) {
            const now = Date.now();
            if (now - lastTouchMove < 16) return; // ~60fps
            lastTouchMove = now;
            draw(e);
        }
        
        // Mesmas correções para o dialog canvas
        function startDialogDrawing(e) {
            e.preventDefault();
            isDialogDrawing = true;
            const coords = getPointerPos(e, dialogCanvas);
            dialogCurrentPath = [{ x: coords.x, y: coords.y, color: currentColor }];
            dialogPaths.push(dialogCurrentPath);
            dialogCtx.beginPath();
            dialogCtx.moveTo(coords.x, coords.y);
        }
        
        function drawDialog(e) {
            if (!isDialogDrawing) return;
            e.preventDefault();
            const coords = getPointerPos(e, dialogCanvas);
            dialogCurrentPath.push({ x: coords.x, y: coords.y, color: currentColor });
            redrawDialogCanvas();
        }
        
        function stopDialogDrawing() {
            isDialogDrawing = false;
            dialogCurrentPath = [];
        }
        
        let lastDialogTouchMove = 0;
        function throttledDrawDialog(e) {
            const now = Date.now();
            if (now - lastDialogTouchMove < 16) return;
            lastDialogTouchMove = now;
            drawDialog(e);
        }
        
        // Botão Limpar
        clearBtn.addEventListener('click', function() {
            clearCanvas(ctx, canvas);
            signatureHistory = [];
            hasSignature = false;
            updateSignButton();
        });
        
        // Botão Desfazer
        undoBtn.addEventListener('click', function() {
            if (signatureHistory.length > 0) {
                signatureHistory.pop();
                redrawCanvas();
                hasSignature = signatureHistory.length > 0;
                updateSignButton();
            }
        });
        
        // Função para redesenhar o canvas
        function redrawCanvas() {
            clearCanvas(ctx, canvas);
            setupCanvasContext(); // garante lineWidth/estilos
            
            signatureHistory.forEach(path => {
                if (path.length > 0) {
                    ctx.strokeStyle = path[0].color || '#000';
                    ctx.beginPath();
                    ctx.moveTo(path[0].x, path[0].y);
                    for (let i = 1; i < path.length; i++) {
                        ctx.lineTo(path[i].x, path[i].y);
                    }
                    ctx.stroke();
                }
            });
        }
        
        function redrawDialogCanvas() {
            clearCanvas(dialogCtx, dialogCanvas);
            setupDialogContext();
            
            dialogPaths.forEach(path => {
                if (path.length > 0) {
                    dialogCtx.strokeStyle = path[0].color || currentColor || '#000';
                    dialogCtx.beginPath();
                    dialogCtx.moveTo(path[0].x, path[0].y);
                    for (let i = 1; i < path.length; i++) {
                        dialogCtx.lineTo(path[i].x, path[i].y);
                    }
                    dialogCtx.stroke();
                }
            });
        }
        
        // Função para atualizar estado do botão de assinatura
        function updateSignButton() {
            if (signBtn) {
                signBtn.disabled = !hasSignature;
                console.log('Botão assinatura:', hasSignature ? 'Habilitado' : 'Desabilitado');
                console.log('signBtn.disabled:', signBtn.disabled);
            } else {
                console.error('signBtn não encontrado em updateSignButton!');
            }
        }
        
         // Dialog functions with animations
         function openSignatureDialog() {
             // Prevent body scroll and add class
             document.body.style.overflow = 'hidden';
             document.body.classList.add('dialog-open');
             
             // Add active class for animation
             signatureDialog.classList.add('active');
             
             // Setup canvas after animation starts with delay for proper rendering
             setTimeout(() => {
                 setupDialogCanvas();
                 copyCanvasToDialog();
             }, 100); // Increased delay for better rendering
         }
         
         function closeSignatureDialog() {
             signatureDialog.classList.remove('active');
             
             // Wait for animation to complete before hiding
             setTimeout(() => {
                 // Restore body scroll and remove class
                 document.body.style.overflow = '';
                 document.body.classList.remove('dialog-open');
             }, 400); // Match animation duration
         }
         
        // Desktop expand button (only visible on desktop)
        if (!isMobile && !isTablet) {
            expandBtn.addEventListener('click', () => {
                openSignatureDialog();
            });
        }
         
         // Dialog close buttons
         dialogCloseBtn.addEventListener('click', closeSignatureDialog);
         dialogDoneBtn.addEventListener('click', () => {
             copyDialogToCanvas();
             closeSignatureDialog();
         });
         
         // Close dialog when clicking on background
         signatureDialog.addEventListener('click', (e) => {
             if (e.target === signatureDialog) {
                 closeSignatureDialog();
             }
         });
         
         // Prevent dialog content clicks from closing dialog
         document.querySelector('.dialog-content').addEventListener('click', (e) => {
             e.stopPropagation();
         });
         
         // Copia o conteúdo da página para o dialog (reescalando paths)
         function copyCanvasToDialog() {
             // Converte histórico da página (main) para o tamanho do dialog
             dialogPaths = scalePaths(
                 signatureHistory,
                 mainLogicalSize.w, mainLogicalSize.h,
                 dialogLogicalSize.w, dialogLogicalSize.h
             );
             // Redesenha no dialog
             redrawDialogCanvas();
         }
         
         // Copia o conteúdo do dialog para a página (reescalando paths)
         function copyDialogToCanvas() {
             // Converte histórico do dialog para o tamanho da página
             signatureHistory = scalePaths(
                 dialogPaths,
                 dialogLogicalSize.w, dialogLogicalSize.h,
                 mainLogicalSize.w, mainLogicalSize.h
             );
             // Redesenha na página
             redrawCanvas();
             hasSignature = signatureHistory.length > 0;
             updateSignButton();
         }
         
         // Dialog mouse events
         dialogCanvas.addEventListener('mousedown', startDialogDrawing);
         dialogCanvas.addEventListener('mousemove', drawDialog);
         dialogCanvas.addEventListener('mouseup', stopDialogDrawing);
         dialogCanvas.addEventListener('mouseout', stopDialogDrawing);
         
         // Dialog touch events
         dialogCanvas.addEventListener('touchstart', (e) => {
             if (e.touches.length > 1) return;
             startDialogDrawing(e);
         }, { passive: true });
         
         dialogCanvas.addEventListener('touchmove', throttledDrawDialog, { passive: true });
         dialogCanvas.addEventListener('touchend', stopDialogDrawing, { passive: true });
         
         // Dialog pointer events
         dialogCanvas.addEventListener('pointerdown', (e) => {
             if (e.pointerType === 'touch') {
                 dialogCanvas.setPointerCapture(e.pointerId);
                 startDialogDrawing(e);
             }
         });
         dialogCanvas.addEventListener('pointermove', (e) => {
             if (e.pointerType === 'touch' && isDialogDrawing) {
                 drawDialog(e);
             }
         });
         dialogCanvas.addEventListener('pointerup', (e) => {
             if (e.pointerType === 'touch') {
                 stopDialogDrawing(e);
             }
         });
         
        // Dialog controls
        dialogClearBtn.addEventListener('click', () => {
            clearCanvas(dialogCtx, dialogCanvas);
            dialogPaths = [];
        });
        
        dialogUndoBtn.addEventListener('click', () => {
            if (dialogPaths.length > 0) {
                dialogPaths.pop();
                redrawDialogCanvas();
            }
        });
        
        // Color picker for dialog
        document.querySelectorAll('.color-picker').forEach(picker => {
            picker.addEventListener('click', function() {
                document.querySelectorAll('.color-picker').forEach(p => p.classList.remove('active'));
                this.classList.add('active');
                currentColor = this.dataset.color;
                dialogCtx.strokeStyle = currentColor;
            });
        });
         
        
        // Enhanced Finalizar Assinatura button with Pointer Events
        console.log('Configurando event listener para signBtn:', signBtn);
        if (signBtn) {
            // Handler unificado com Pointer Events (melhor compatibilidade)
            const handleSignClick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                console.log('Botão clicado! hasSignature:', hasSignature);
                console.log('Event type:', e.type, 'Pointer type:', e.pointerType);
                console.log('Botão disabled:', signBtn.disabled);
            
            if (!hasSignature) {
                console.log('Sem assinatura, mostrando modal de validação');
                // HUD de validação com fallback para Samsung Internet
                document.getElementById('signValidationText').textContent = 'Por favor, desenhe sua assinatura antes de continuar.';
                showModalWithFallback('signValidationModal');
                return;
            }

            // Mostra HUD de confirmação com fallback
            showModalWithFallback('signConfirmModal');

            const doSign = () => {
                // Fecha modal de confirmação
                const confirmModalEl = document.getElementById('signConfirmModal');
                if (confirmModalEl) {
                    confirmModalEl.style.display = 'none';
                    confirmModalEl.classList.remove('show');
                    const backdrop = document.getElementById('modal-backdrop-signConfirmModal');
                    if (backdrop) backdrop.remove();
                    document.body.style.overflow = '';
                }
                document.getElementById('signConfirmBtn').removeEventListener('click', doSign);

                // Desabilita botão para evitar duplo envio
                signBtn.disabled = true;
                signBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processando...';
                
                // Converte canvas para base64
                const signatureData = canvas.toDataURL('image/png');
                
                // Coleta informações do dispositivo
                const deviceInfo = collectDeviceInfo();
                
                // Envia assinatura para o servidor
                fetch("{{ url_for('client_sign_document', signature_id=signature.id) }}", {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Screen-Resolution': deviceInfo.screenResolution,
                        'X-Timezone': deviceInfo.timezone
                    },
                    body: JSON.stringify({
                        signature_image: signatureData,
                        device_info: deviceInfo
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // HUD de sucesso
                        document.getElementById('signSuccessText').textContent = 'Assinatura realizada com sucesso!';
                        showModalWithFallback('signSuccessModal');
                        setTimeout(() => { window.location.href = data.redirect; }, 800);
                    } else {
                        // HUD de erro
                        document.getElementById('signErrorText').textContent = 'Erro ao processar assinatura: ' + (data.message || 'Tente novamente.');
                        showModalWithFallback('signErrorModal');
                        signBtn.disabled = false;
                        signBtn.innerHTML = '<i class="fas fa-check me-2"></i>Finalizar Assinatura';
                    }
                })
                .catch(error => {
                    console.error('Erro:', error);
                    document.getElementById('signErrorText').textContent = 'Erro ao processar assinatura. Tente novamente.';
                    showModalWithFallback('signErrorModal');
                    signBtn.disabled = false;
                    signBtn.innerHTML = '<i class="fas fa-check me-2"></i>Finalizar Assinatura';
                });
            };
            document.getElementById('signConfirmBtn').addEventListener('click', doSign);
            };
            
            // Pointer Events como handler principal (melhor compatibilidade cross-device)
            signBtn.addEventListener('pointerup', handleSignClick);
            
            // Fallback para browsers antigos
            signBtn.addEventListener('click', handleSignClick);
            
            // Touch fallback específico para Samsung Internet
            if (navigator.userAgent.includes('SamsungBrowser')) {
                signBtn.addEventListener('touchend', handleSignClick);
            }
            
        } else {
            console.error('signBtn não encontrado, não é possível configurar event listener!');
        }
        
        // Função de fallback para modais (Samsung Internet compatibility)
        function showModalWithFallback(modalId) {
            const modalElement = document.getElementById(modalId);
            if (!modalElement) {
                console.error('Modal não encontrado:', modalId);
                return;
            }
            
            // Para Samsung Internet, usa fallback direto
            if (isSamsungInternet) {
                console.log('Samsung Internet detectado, usando fallback direto');
                showModalFallback(modalElement, modalId);
                return;
            }
            
            try {
                // Tenta usar Bootstrap Modal primeiro
                const modal = new bootstrap.Modal(modalElement);
                modal.show();
                console.log('Modal Bootstrap exibido:', modalId);
            } catch (error) {
                console.warn('Bootstrap Modal falhou, usando fallback:', error);
                showModalFallback(modalElement, modalId);
            }
        }
        
        function showModalFallback(modalElement, modalId) {
            // Fallback: exibe modal manualmente
            modalElement.style.display = 'block';
            modalElement.classList.add('show');
            modalElement.setAttribute('aria-modal', 'true');
            modalElement.setAttribute('role', 'dialog');
            
            // Adiciona backdrop
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop fade show';
            backdrop.id = 'modal-backdrop-' + modalId;
            document.body.appendChild(backdrop);
            
            // Previne scroll do body
            document.body.style.overflow = 'hidden';
            
            // Adiciona listener para fechar modal
            const closeModal = () => {
                modalElement.style.display = 'none';
                modalElement.classList.remove('show');
                modalElement.removeAttribute('aria-modal');
                modalElement.removeAttribute('role');
                
                const backdropEl = document.getElementById('modal-backdrop-' + modalId);
                if (backdropEl) {
                    backdropEl.remove();
                }
                
                document.body.style.overflow = '';
            };
            
            // Fecha modal ao clicar no backdrop
            modalElement.addEventListener('click', (e) => {
                if (e.target === modalElement) {
                    closeModal();
                }
            });
            
            // Fecha modal ao clicar no X
            const closeBtn = modalElement.querySelector('.btn-close');
            if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
            }
            
            // Fecha modal ao pressionar ESC
            const handleEsc = (e) => {
                if (e.key === 'Escape') {
                    closeModal();
                    document.removeEventListener('keydown', handleEsc);
                }
            };
            document.addEventListener('keydown', handleEsc);
            
            console.log('Modal fallback exibido:', modalId);
        }
        
        // Enhanced initialization
        updateSignButton();
        
        // Initialize canvas on load
        window.addEventListener('load', () => {
            resizeCanvas();
            setupDialogCanvas();
        });
        
        // Resize with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas();
                if (signatureDialog.classList.contains('active')) {
                    setupDialogCanvas();
                    setTimeout(() => redrawDialogCanvas(), 100);
                }
            }, 150);
        });
        
        // Previne zoom em dispositivos móveis
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });
        
        document.addEventListener('gesturechange', function(e) {
            e.preventDefault();
        });
        
        document.addEventListener('gestureend', function(e) {
            e.preventDefault();
        });
    </script>
</body>
</html>

